/*
Lv. 3 #64062 - 징검다리 건너기

    문제 설명
        [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

        카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.
            · 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
            · 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
            · 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.

        "니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.
        "니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.
        디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.


    [제한사항]
        · 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
        · stones 배열의 크기는 1 이상 200,000 이하입니다.
        · stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
        · k는 1 이상 stones의 길이 이하인 자연수입니다.


    [입출력 예]
        stones	                            k	    result
        [2, 4, 5, 3, 2, 1, 4, 2, 5, 1]	    3	    3


    입출력 예에 대한 설명
        입출력 예 #1
            첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.
                [그림은 문제에서 참고]

            첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
                두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.
                [그림은 문제에서 참고]

            두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
                세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.
                [그림은 문제에서 참고]

            세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
                네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.
                [그림은 문제에서 참고]

            따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.
*/


/*
    정확성  테스트
        테스트 1 〉    통과 (0.04ms, 74.1MB)
        테스트 2 〉    통과 (0.03ms, 78.2MB)
        테스트 3 〉    통과 (0.04ms, 85MB)
        테스트 4 〉    통과 (0.04ms, 81.1MB)
        테스트 5 〉    통과 (0.06ms, 72.5MB)
        테스트 6 〉    통과 (0.12ms, 88.3MB)
        테스트 7 〉    통과 (0.24ms, 79.6MB)
        테스트 8 〉    통과 (0.23ms, 86.3MB)
        테스트 9 〉    통과 (0.35ms, 75.4MB)
        테스트 10 〉    통과 (0.05ms, 70.2MB)
        테스트 11 〉    통과 (0.06ms, 75MB)
        테스트 12 〉    통과 (0.06ms, 88.8MB)
        테스트 13 〉    통과 (0.04ms, 87.5MB)
        테스트 14 〉    통과 (0.17ms, 90.1MB)
        테스트 15 〉    통과 (0.29ms, 92MB)
        테스트 16 〉    통과 (0.21ms, 91.7MB)
        테스트 17 〉    통과 (0.22ms, 74.9MB)
        테스트 18 〉    통과 (0.05ms, 85.6MB)
        테스트 19 〉    통과 (0.04ms, 89.1MB)
        테스트 20 〉    통과 (0.05ms, 73.6MB)
        테스트 21 〉    통과 (0.14ms, 81MB)
        테스트 22 〉    통과 (0.27ms, 91MB)
        테스트 23 〉    통과 (0.29ms, 83.8MB)
        테스트 24 〉    통과 (0.24ms, 72.3MB)
        테스트 25 〉    통과 (0.04ms, 87.4MB)

    효율성  테스트
        테스트 1 〉    통과 (26.49ms, 63.7MB)
        테스트 2 〉    통과 (26.76ms, 64.3MB)
        테스트 3 〉    통과 (26.31ms, 64.7MB)
        테스트 4 〉    통과 (21.82ms, 82.8MB)
        테스트 5 〉    통과 (19.88ms, 64.1MB)
        테스트 6 〉    통과 (22.03ms, 63.8MB)
        테스트 7 〉    통과 (29.97ms, 64.3MB)
        테스트 8 〉    통과 (35.18ms, 67MB)
        테스트 9 〉    통과 (29.36ms, 63.9MB)
        테스트 10 〉    통과 (30.65ms, 64.2MB)
        테스트 11 〉    통과 (25.91ms, 64.1MB)
        테스트 12 〉    통과 (26.80ms, 63.7MB)
        테스트 13 〉    통과 (24.32ms, 64MB)
        테스트 14 〉    통과 (31.73ms, 63.9MB)

    채점 결과
        정확성: 64.1
        효율성: 35.9
        합계: 100.0 / 100.0
*/


// 정답

package C0012S;

class PRO64062 {
    public boolean canCross(int[] stones, int k, int peopleNum) { // peopleNum 명이 징검다리를 건널 수 있는지 판별하는 메서드
        int space = 1; // 한 번에 건너뛰어야 하는 디딤돌의 칸수

        for (int s = 0, length = stones.length; s < length; s++) {
            if (stones[s] - peopleNum >= 0) { // mid 명이 s 번째 디딤돌을 건널 수 있을 경우
                space = 1;
            }
            else { // mid 명 중 s 번째 디딤돌을 건널 수 없는 니니즈 친구가 있을 경우
                if (space < k) { // 한 번에 건너뛰어야 하는 디딤돌의 칸수가 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수보다 적을 경우
                    space += 1; // 한 번에 건너뛰어야 하는 디딤돌의 칸수 추가
                }
                else {
                    return false;
                }
            }
        }

        return true;
    }

    public int solution(int[] stones, int k) {
        int left = 1; // 징검다리를 건널 수 있는 니니즈 친구들의 수의 범위의 최솟값
        int right = 0; // 징검다리를 건널 수 있는 니니즈 친구들의 수의 범위의 최댓값
        int answer = 0; // 징검다리를 건널 수 있는 최대의 니니즈 친구들의 수

        for (int count : stones) {
            right = Math.max(right, count);
        }

        while (left <= right) {
            int mid = (left + right) / 2; // 징검다리를 건널 수 있는 니니즈 친구들의 수의 범위의 중간값

            if (canCross(stones, k, mid)) { // mid 명이 징검다리를 건널 수 있을 경우
                answer = mid;
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }

        return answer;
    }
}
